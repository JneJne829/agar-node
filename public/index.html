<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Agar-Lite with Feed (Dark Mode)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #111;      /* 深色背景 */
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #111;      /* Canvas 底色同樣設定為深色 */
    }
  </style>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
<canvas id="game"></canvas>
<script>
/* ───────── 參數 ───────────────────── */
const GRID_SIZE      = 100;
const PLAYER_COLORS  = { self: '#ff6666', other: '#66aaff' };
const FEED_COLOR     = '#88cc88';
const WORLD_SIZE     = 2000;

const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d');
function resize() {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
}
/* ───────── 滑鼠座標（螢幕絕對座標） ── */
let mouseScreenX = 0, mouseScreenY = 0;
window.addEventListener('mousemove', e => {
  mouseScreenX = e.clientX;
  mouseScreenY = e.clientY;
});
window.addEventListener('resize', resize);
resize();

/* ───────── 網路與狀態 ───────────── */
const socket  = io();
let   players = {};
let   feeds   = [];
let   myId    = null;

socket.on('connect', () => { myId = socket.id; });
socket.on('state', data => {
  players = data.players;
  feeds   = data.feeds;
});

/* ───────── 滑鼠向量 ─────────────── */
let mouseX = 0, mouseY = 0;
window.addEventListener('mousemove', e => {
  const cx = canvas.width  / 2;
  const cy = canvas.height / 2;
  mouseX = e.clientX - cx;
  mouseY = e.clientY - cy;
});

/* ───────── 繪製迴圈 ─────────────── */
function draw() {
  const me = players[myId];

  /* ---- 計算鏡頭偏移量 (ox, oy) ---- */
  let ox = me ? canvas.width  / 2 - me.x : 0;
  let oy = me ? canvas.height / 2 - me.y : 0;

  // 將鏡頭限制在世界邊界內
  const halfWorld = WORLD_SIZE / 2;
  const minOx = canvas.width  - halfWorld;
  const maxOx = halfWorld;
  const minOy = canvas.height - halfWorld;
  const maxOy = halfWorld;
  ox = Math.min(maxOx, Math.max(minOx, ox));
  oy = Math.min(maxOy, Math.max(minOy, oy));

  /* ---- 根據玩家在螢幕上的實際位置計算方向向量 ---- */
  if (me) {
    const playerScreenX = me.x + ox;
    const playerScreenY = me.y + oy;
    const relX = mouseScreenX - playerScreenX;
    const relY = mouseScreenY - playerScreenY;
    const dist = Math.hypot(relX, relY);
    const dx   = dist ? relX / dist : 0;
    const dy   = dist ? relY / dist : 0;
    socket.emit('move', { dx, dy });
  }

  /* ---- 以下繪製程式全部改用 (ox, oy) ---- */
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 背景格線
  ctx.strokeStyle = '#444';
  ctx.lineWidth   = 1;
  let startX = (ox % GRID_SIZE) - GRID_SIZE;
  let startY = (oy % GRID_SIZE) - GRID_SIZE;
  for (let x = startX; x < canvas.width; x += GRID_SIZE) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
  for (let y = startY; y < canvas.height; y += GRID_SIZE) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }

  // Feed
  for (const f of feeds) {
    ctx.beginPath();
    ctx.arc(f.x + ox, f.y + oy, f.size, 0, Math.PI * 2);
    ctx.fillStyle = FEED_COLOR;
    ctx.fill();
  }

  // Players
  for (const id in players) {
    const p = players[id];
    ctx.beginPath();
    ctx.arc(p.x + ox, p.y + oy, p.size, 0, Math.PI * 2);
    ctx.fillStyle = id === myId ? PLAYER_COLORS.self : PLAYER_COLORS.other;
    ctx.fill();
  }

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
