<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Agar-Lite with Feed (Dark Mode)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #111;      /* 深色背景 */
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #111;      /* Canvas 底色同樣設定為深色 */
    }
  </style>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
<canvas id="game"></canvas>
<script>
/* ───────── 參數 ───────────────────── */
const GRID_SIZE      = 100;
const PLAYER_COLORS  = { self: '#ff6666', other: '#66aaff' };
const FEED_COLOR     = '#88cc88';
const WORLD_SIZE     = 6000;       // 與伺服器一致
const BASE_SCALE     = 2;          // 基準倍率
const MIN_ZOOM       = 0.6;        // 視野最遠（越小越遠）
const MAX_ZOOM       = 1.8;        // 視野最近（越大越近）
let   zoom           = BASE_SCALE; // 當前平滑縮放值


const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d');
function resize() {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
}
/* ───────── 滑鼠座標 (螢幕絕對座標) ───── */
let mouseScreenX = 0, mouseScreenY = 0;
window.addEventListener('mousemove', e => {
  mouseScreenX = e.clientX;
  mouseScreenY = e.clientY;
});
window.addEventListener('resize', resize);
resize();

/* ───────── 網路與狀態 ───────────── */
const socket  = io();
let   players = {};
let   feeds   = [];
let   myId    = null;
const smoothSize = new Map();

socket.on('connect', () => { myId = socket.id; });
socket.on('state', data => {
  players = data.players;
  feeds   = data.feeds;
});

/* ───────── 滑鼠向量 ─────────────── */
let mouseX = 0, mouseY = 0;
window.addEventListener('mousemove', e => {
  const cx = canvas.width  / 2;
  const cy = canvas.height / 2;
  mouseX = e.clientX - cx;
  mouseY = e.clientY - cy;
});

/* ───────── 繪製迴圈 ─────────────── */
function draw() {
  const me = players[myId];

  /* ── 1. 根據玩家大小計算平滑縮放 ── */
  if (me) {
    // 採用平方根函式，放大變得更「緩」，避免一下子縮太遠
    const targetScale = BASE_SCALE * Math.sqrt(20 / me.size);
    // 夾在可接受範圍
    const clamped     = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, targetScale));
    zoom += (clamped - zoom) * 0.08;          // 緩動 8%
  }

  /* ── 2. 計算攝影機中心 (camX, camY) 並夾在世界邊界 ── */
  let camX = 0, camY = 0;
  if (me) {
    const halfWorld = WORLD_SIZE / 2;
    const viewHalfW = canvas.width  / (2 * zoom);
    const viewHalfH = canvas.height / (2 * zoom);

    // 若螢幕視口比世界還大，就直接置中
    if (viewHalfW >= halfWorld) camX = 0;
    else {
      camX = Math.min(halfWorld - viewHalfW,
             Math.max(-halfWorld + viewHalfW, me.x));
    }

    if (viewHalfH >= halfWorld) camY = 0;
    else {
      camY = Math.min(halfWorld - viewHalfH,
             Math.max(-halfWorld + viewHalfH, me.y));
    }
  }

  /* ── 3. 依縮放與攝影機變換 Canvas ── */
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.scale(zoom, zoom);
  ctx.translate(-camX, -camY);

  /* ── 4. 背景格線 ── */
  ctx.strokeStyle = '#444';
  ctx.lineWidth   = 1 / zoom;              // 線寬需隨縮放調整
  const startGridX = Math.floor((-WORLD_SIZE / 2) / GRID_SIZE) * GRID_SIZE;
  const endGridX   =  Math.ceil(( WORLD_SIZE / 2) / GRID_SIZE) * GRID_SIZE;
  const startGridY = Math.floor((-WORLD_SIZE / 2) / GRID_SIZE) * GRID_SIZE;
  const endGridY   =  Math.ceil(( WORLD_SIZE / 2) / GRID_SIZE) * GRID_SIZE;

  for (let x = startGridX; x <= endGridX; x += GRID_SIZE) {
    ctx.beginPath(); ctx.moveTo(x, -WORLD_SIZE/2); ctx.lineTo(x, WORLD_SIZE/2); ctx.stroke();
  }
  for (let y = startGridY; y <= endGridY; y += GRID_SIZE) {
    ctx.beginPath(); ctx.moveTo(-WORLD_SIZE/2, y); ctx.lineTo(WORLD_SIZE/2, y); ctx.stroke();
  }

  /* ── 5. 繪製 feeds ── */
  feeds.forEach(f => {
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
    ctx.fillStyle = FEED_COLOR;
    ctx.fill();
  });

  /* ── 6. 繪製玩家 (含平滑尺寸) ── */
  for (const id in players) {
    const p = players[id];
    // 若尚無記錄，初始化
    if (!smoothSize.has(id)) smoothSize.set(id, p.size);

    // 每幀以 10% 緩動逼近真實大小
    const prev = smoothSize.get(id);
    const next = prev + (p.size - prev) * 0.025;
    smoothSize.set(id, next);

    ctx.beginPath();
    ctx.arc(p.x, p.y, next, 0, Math.PI * 2);
    ctx.fillStyle = id === myId ? PLAYER_COLORS.self : PLAYER_COLORS.other;
    ctx.fill();
  }

  ctx.restore();

  /* ── 7. 計算並送出移動向量 (以世界座標) ── */
  if (me) {
    const worldMouseX = camX + (mouseScreenX - canvas.width  / 2) / zoom;
    const worldMouseY = camY + (mouseScreenY - canvas.height / 2) / zoom;
    const relX = worldMouseX - me.x;
    const relY = worldMouseY - me.y;
    const dist = Math.hypot(relX, relY);
    const dx   = dist ? relX / dist : 0;
    const dy   = dist ? relY / dist : 0;
    socket.emit('move', { dx, dy });
  }

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
